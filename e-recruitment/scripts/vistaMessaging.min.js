/*****************************************************************************
 *
 * COPYRIGHT       :   COPYRIGHT PHOENIX INTERACTIVE DESIGN INC. 2015
 *                     LICENSED MATERIAL - PROGRAM PROPERTY OF PHOENIX
 *                     INTERACTIVE DESIGN INC. ALL RIGHTS RESERVED
 *
 * $Source: vistaMessaging.min.js $
 * $Author: Andrew Fontaine (AFontaine) $
 * $Date: 2016/01/27 11:24:58EST $
 * $Revision: 1.2 $
 *
 ******************************************************************************/
var phoenix = phoenix || {};

phoenix.guid = function guid() {
  var d = new Date().getTime();
  var id = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'
    .replace(
      /[xy]/g,
      function(c) {
        var r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
      });
  return id;
};

/*
 config must be an object with the configuration required by this service
 config.notificationsBindingName - a string containing a name for the binding
 that will be used to identify unsolicited calls made by
 native Vista services
 config.requestsBindingName      - a string containing the name for the binding
 used by request callbacks
 */
phoenix.messagingFactory = function(config) {
  //INTERNAL class definitions

  var MsgHeader = (function() {
    function MsgHeader(uri, method) {
      if (!(this instanceof MsgHeader)) {
        return new MsgHeader();
      }

      //Unique Resource Identifier.
      if (!uri || typeof uri !== 'string' || uri === '') {
        throw 'invalid uri';
      }
      //validate method
      if (!method ||
        !(method === 'POST' ||
          method === 'PUT' ||
          method === 'GET' ||
          method === 'PATCH' ||
          method === 'DELETE')) {
        throw 'invalid method';
      }
      this.uri = uri;

      // GET|POST|PUT|DELETE|PATCH
      this.method = method;

      /*
       Unique request identifier. The response will include this id.
       A retried request uses this same id.
       SV112015 todo it should be one implementation of GUID. there is another one in 'Transaction'
       */
      this.requestId = phoenix.guid();

      this.prevRequestId = '';

      /*
       userId of who initiated the message.
       Messages for a given sender have to be processed in the order they were sent.
       When the message comes from VISTA, if there is no user authentication yet,
       use “atm” or the name of the ATM if that is known
       SV112015 todo this should be coming maybe from a config file
       */
      this.senderId = 'VISTAjs';

      /*
       Type of the original change-message originator: MASTER | MIRROR | OTHER
       TODO: obtain default value from TerminalSession or SSp or configuration settings
       */
      this.senderType = 'UI';

      /*
       It identifies the message; requests, responses and notifications get a different one, as well as any message
       that is retried. If the message is forwarded, it would have a new id.
       it could be re-assigned by onBeforeSendingMessage member.
       sv112015 todo this should be the same as the one usedby 'Transaction'
       */
      this.messageId = phoenix.guid();

      /*
       date-time when the message was originally generated as a GMT string
       */
      this.sent = '';

      /*
       resent
       date-time when the message was forwarded as a GMT string
       Sync messages sent by session-change publishing as well as pass-through messages use this field.
       null properties should not be included in the serialized result
       */
      this.resent = null;

      /*
       Date-Time when the message will expire and become invalid.
       A forwarded or retried message get a new expiration value.
       */
      this.expires = '';

      /*
       ‘True’ if message was resent after timing-out. It is optional, defaulting to false.
       */
      //this.isRetry = false; //todo: add only when true done in onBeforeSendingMessage. Leave jsDOC only

      /*
       Version of the schema used to encode the message data (for backwards compatibility needed during software upgrades).
       */
      this.schema = '0.1';

      /*
       by default this would be a SHA-2 hash. If keys are available then it can be either a mac or a signature
       Message authentication code. A Cryptographic hash used to verify
       the message originator (last sender in the route) and integrity of the message contents. RSA-SHA256
       Security.AuthenticateMessage will take the mac and turn it into either
       a userSignature
       or terminalSignature
       */
      //this.mac = ''; //todo leave jsdoc only

      /*
       Commander authorization Session Id is the one granted to the original sender.
       This is kept in the header as the synchronization messages are sent to subscribers.
       The Security solution has to be designed. The use of this token may change.
       */
      this.cmdAuthId = '';

      /*
       User Authorization Session Token that is included in messages sent by the node to servers
       when the session has been established. This does not represent the same session that is being synchronized.
       This is omitted in a message that has been forwarded.
       Added through the Security.AuthenticateUser
       The Security solution has to be designed. The use of this token may change.
       */
      //this.AuthToken; //todo leave jsdoc only

      /*
       A token corresponding to the Terminal session that has been established with Commander.
       This is needed only for messages that are sent by the node when there is no user session available.
       Added through the Security.AuthenticateTerminal
       The Security solution has to be designed. The use of this token may change.
       */
      //this.nodeAuthToken; //todo leave jsdoc only

    }

    /*This is added by message originator and used to enforce a strict sequential order.
     It is mandatory. It is forwarded as needed.
     */
    MsgHeader.prevRequestId = '';
    function onNewSession() {
      MsgHeader.prevRequestId = '';
    }

    MsgHeader.prototype.getProtectedStrings = function() {
      return this.uri +
        this.method +
        this.requestId +
        this.senderId +
        this.messageId +
        this.expires +
        this.cmdAuthId;
    };

    MsgHeader.prototype.hasContents = function() {
      return true;
    };

    return MsgHeader;
  })();

  var MsgBody = (function() {
    function MsgBody(data) {
      if (!(this instanceof MsgBody)) {
        return new MsgBody();
      }
      if (!!data && typeof data !== 'string') {
        this.data = data;
      } else {
        this.data = JSON.parse(data);
      }
    }

    MsgBody.prototype.getProtectedStrings = function() {
      if (!this.data) {
        return '';
      }
      return JSON.stringify(this);
    };
    MsgBody.prototype.hasContents = function() {
      return !!this.data;
    };

    MsgBody.prototype.toJSON = function() {
      return this.data;
    };

    return MsgBody;
  })();

  var ErrorResponse = (function() {
    function ErrorResponse(errorMessage, source, level) {
      if (!(this instanceof ErrorResponse)) {
        return new ErrorResponse();
      }

      if (!errorMessage || errorMessage === '') {
        throw 'error message cannot be empty';
      }
      if (!source || source === '') {
        //SV112015 TODO this has to come from a globally available static and configurable
        //atm vta are possibilities
        source = 'atm';
      }
      if (!level || isNaN(level)) {
        level = 0;
      }

      this.errorMessage = errorMessage;
      this.source = source;
      this.level = level;
    }

    ErrorResponse.prototype.getProtectedStrings = function() {
      return this.errorMessage + this.source + this.level;
    };
    ErrorResponse.prototype.hasContents = function() {
      return (!!this.error && typeof this.error === 'object');
    };
    return ErrorResponse;
  })();

  var VistaMessage = (function() {
    var MSG_MAX_AUTO_RETRIES = 0;
    //constructor
    function VistaMessage(uri, method, data, lapse) {
      if (!(this instanceof VistaMessage)) {
        return new VistaMessage();
      }

      this.header = new MsgHeader(uri, method);
      this.body = new MsgBody(data);
      this.retriesLeft = MSG_MAX_AUTO_RETRIES;

      this.timerId = -1;
      if (isNaN(lapse)) {
        lapse = config.vistaTimeout;
      }
      this.lapse = lapse;

      var setResolve = (
        function(resolve) {
          this.resolve = function(data) {
            this.stop();
            VistaMessages.remove(this);
            resolve(data);
          };
        }
      ).bind(this);

      var setReject = (
        function(reject) {
          this.reject = function(reason) {
            console.log('rejecting: ' + this.uri + ' - ' + this.id);
            this.stop();
            VistaMessages.remove(this);
            reject(reason);
          };
        }
      ).bind(this);

      function executor(resolve, reject) {
        setResolve(resolve);
        setReject(reject);
      }

      this.promise = new Promise(executor);
    }

    //methods
    VistaMessage.prototype.start = function() {
      if (this.lapse !== Number.MAX_VALUE) {
        this.timerId = window.setTimeout(this.onTimeout(
          this.header.requestId
        ), this.lapse);
        console.log(
          'starting: ' +
          this.header.uri +
          '; requestId=' +
          this.header.requestId +
          '; timerId=' + this.timerId
        );
      }
    };

    VistaMessage.prototype.stop = function() {
      if (this.timerId >= 0) {
        console.log(
          'ending: ' +
          this.header.uri +
          '; requestId=' +
          this.header.requestId +
          '; timerId=' + this.timerId
        );
        window.clearTimeout(this.timerId);
        this.timerId = -1;
      }
    };

    VistaMessage.prototype.abort = function(reason, reject) {
      this.stop();
      if (reject) {
        this.reject('aborted');
      }
      VistaMessages.remove(this);
    };

    VistaMessage.prototype.send = function() {
      this.onBeforeSendingMessage();
      //start the message expiration timer
      this.start();
      VistaMessages.ws.send(this.getMessageJSON());
      this.onAfterSendingMessage();
      return this.promise;
    };

    VistaMessage.prototype.resend = function() {
      this.onBeforeSendingMessage(true);
      //start the message expiration timer
      this.start();
      VistaMessages.ws.send(this.getMessageJSON());
      this.onAfterSendingMessage();
      //do not recreate or reject the promise
      return this.promise;
    };

    VistaMessage.prototype.onTimeout = function(requestId) {
      var id;
      if (!!requestId) {
        id = requestId;
      } else {
        if (typeof(this.header.requestId) !== 'undefined') {
          id = this.header.requestId;
        }
      }
      var timeoutCb = function() {
        var message = VistaMessages.getPendingMessage(id);
        if (message.retriesLeft <= 0) {
          console.log('timed out: ' + message.uri);
          message.reject('request timed out', message);
        } else {
          message.resend();
        }
      };
      return timeoutCb;
    };

    VistaMessage.prototype.getProtectedStrings = function() {
      var s = this.header.getProtectedStrings();
      if (!!this.body) {
        s += this.body.getProtectedStrings;
      }
      if (!!this.error) {
        s += this.error.getProtectedStrings;
      }
      return s;
    };

    VistaMessage.prototype.hashTheMessage = function() {
      var ps = this.getProtectedStrings();
      this.header.mac = CryptoJS.SHA256(ps).toString(CryptoJS.enc.Base64);
    };

    //not used as an event handler. it is called after the message has been sent
    VistaMessage.prototype.onBeforeSendingMessage = function(
      isRetry,
      isForwarding
    ) {

      this.header.messageId = phoenix.guid();
      this.header.expires = (new Date(Date.now() + 10000)).toUTCString();

      if (!isForwarding) {
        this.header.sent = (new Date(Date.now())).toUTCString();
      } else {
        this.header.resent = (new Date(Date.now())).toUTCString();
      }
      if (!!isRetry) {
        this.header.resent = (new Date(Date.now())).toUTCString();
        this.header.isRetry = true;
      }
      //protect it here
      this.hashTheMessage();
    };

    VistaMessage.prototype.onAfterSendingMessage = function() {
      //use queue or stack
      MsgHeader.prevRequestId = this.header.requestId;
      this.retriesLeft--;
    };

    VistaMessage.prototype.getMessageJSON = function() {
      var msg = {
        header: this.header
      };
      if (this.body.hasContents()) {
        msg.body = this.body;
      } else {
        if (this.error.hasContents()) {
          msg.body = {
            error: this.error
          };
        }
      }
      return JSON.stringify(msg);
    };

    VistaMessage.prototype.toJSON = function() {
      throw 'call getMessageJSON instead';
    };

    return VistaMessage;
  })();

  // VistaMessages class definition
  function VistaMessages() {}

  if (phoenix.vista && phoenix.vista.EventService) {
    VistaMessages.publish = phoenix.vista.EventService.publish;
  }

  // public statics
  VistaMessages.send = function(uri, method, data, lapse) {
    return VistaMessages.getNew(uri, method, data, lapse).send();
  };

  VistaMessages.getNew = function(uri, method, data, lapse) {
    var req = new VistaMessage(uri, method, data, lapse);
    VistaMessages.pending.push(req);
    return req;
  };

  VistaMessages.resolve = function(id, data) {
    VistaMessages.getPendingMessage(id).resolve(data);
  };

  VistaMessages.reject = function(id, reason) {
    VistaMessages.getPendingMessage(id).reject(reason);
  };

  VistaMessages.abort = function(id, reason, reject) {
    VistaMessages.getPendingMessage(id).abort(reason, reject);
  };

  VistaMessages.remove = function(message) {
    VistaMessages.removePendingMessage(message.header.requestId);
  };

  // private statics
  VistaMessages.getPendingMessage = function(id) {
    var match = VistaMessages.pending.filter(function(message) {
      return message.header.requestId === id;
    });
    if (match.length === 1) {
      return match[0];
    } else {
      return null;
    }
  };

  VistaMessages.removePendingMessage = function(id) {
    VistaMessages.pending = VistaMessages.pending.filter(function(message) {
      return message.header.requestId !== id;
    });
  };

  VistaMessages.pending = [];

  VistaMessages.onMessageReceived = function(event) {
    console.info('data received:' + event.data);
    var inMsg;
    try {
      inMsg = JSON.parse(event.data);
      if (typeof inMsg.body === 'string') {
        inMsg.body = JSON.parse(inMsg.body);
      }
      // otherwise the body is assumed to be already an Object
    } catch (e) {
      console.error(
        'incoming message JSON error: {0}; message:{1}',
        e,
        event.data
      );
      return;
    }
    var pendingRequest;
    var requestId;
    var msgId;
    //is it an event or a response?
    try {

      requestId = inMsg.header.requestId;
      if (!requestId || requestId === '') {
        /*
        when requestId is not defined, it is en event.
         In the case of SSp EVENTS sent to SSjs the messageId attribute will contain
         the eventName expected by VISTAjs.
         */
        msgId = inMsg.header.messageId;
        if (!msgId || msgId === '') {
          throw 'invalid messageId, null or empty';
        }

        VistaMessages.publish(msgId, inMsg.body);
        return;
      }
      pendingRequest = VistaMessages.getPendingMessage(requestId);
    } catch (e) {
      console.error('response to an unknown message was received + response=');
    }
    try {
      //1) VALIDATE: contents and security
      //2) ist it ERROR ?
      //3) RESOLVE promise
      if (!!inMsg.body.error) {
        pendingRequest.reject({
          error: inMsg.body.error
        });
      } else {
        pendingRequest.resolve(inMsg.body);
      }
    } catch (e) {
      pendingRequest.reject({
        error: e,
        response: inMsg
      });
    }
  };

  VistaMessages.connectToSS = function() {

    VistaMessages.ws = new WebSocket(config.url);

    VistaMessages.ws.onmessage = VistaMessages.onMessageReceived;

    var setResolve = function(resolve) {
      VistaMessages.ws.resolve = function(data) {
        resolve(data);
      };
    };

    var setReject = function(reject) {
      VistaMessages.ws.reject = function(reason) {
        reject(reason);
      };
    };

    function executor(resolve, reject) {
      setResolve(resolve);
      setReject(reject);
    }

    var promise = new Promise(executor);

    VistaMessages.ws.onopen = function() {
      console.log('ws,onopen, readystate=' + VistaMessages.ws.readyState);
      VistaMessages.ws.resolve();
    };

    VistaMessages.ws.onerror = function(error) {
      console.log('ws,onerror');
      VistaMessages.ws.reject(error);
    };

    return promise;
  };

  return VistaMessages;

};
